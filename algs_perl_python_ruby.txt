Important Algorithms in Software Development

1. Sorting Algorithms:
   - Bubble Sort:
     - Explanation: Bubble Sort is a simple sorting algorithm used when a small number of elements are already sorted, or when the input size is small.
     - Language: Perl 5
     ```
     sub bubble_sort {
         my $arr = shift;
         my $n = scalar(@$arr);
         for my $i (0 .. $n - 1) {
             for my $j (0 .. $n - $i - 1) {
                 if ($arr->[$j] > $arr->[$j + 1]) {
                     ($arr->[$j], $arr->[$j + 1]) = ($arr->[$j + 1], $arr->[$j]);
                 }
             }
         }
     }
     ```
     - Language: Python
     ```
     def bubble_sort(arr):
         n = len(arr)
         for i in range(n - 1):
             for j in range(n - i - 1):
                 if arr[j] > arr[j + 1]:
                     arr[j], arr[j + 1] = arr[j + 1], arr[j]
     ```
     - Language: Ruby on Rails
     ```
     def bubble_sort(arr)
         n = arr.length
         for i in 0..n - 1
             for j in 0..n - i - 2
                 if arr[j] > arr[j + 1]
                     arr[j], arr[j + 1] = arr[j + 1], arr[j]
                 end
             end
         end
     end
     ```

   - Merge Sort:
     - Explanation: Merge Sort is a divide-and-conquer algorithm that divides the input into smaller parts, sorts them individually, and then merges them to obtain a sorted result.
     - Language: Perl 5
     ```
     sub merge_sort {
         my $arr = shift;
         my $n = scalar(@$arr);
         return $arr if $n <= 1;
         my $mid = int($n / 2);
         my $left = merge_sort([@$arr[0 .. $mid - 1]]);
         my $right = merge_sort([@$arr[$mid .. $n - 1]]);
         return merge($left, $right);
     }
     
     sub merge {
         my ($left, $right) = @_;
         my $result = [];
         while (@$left && @$right) {
             if ($left->[0] <= $right->[0]) {
                 push @$result, shift @$left;
             } else {
                 push @$result, shift @$right;
             }
         }
         push @$result, @$left if @$left;
         push @$result, @$right if @$right;
         return $result;
     }
     ```
     - Language: Python
     ```
     def merge_sort(arr):
         n = len(arr)
         if n <= 1:
             return arr
         mid = n // 2
         left = merge_sort(arr[:mid])
         right = merge_sort(arr[mid:])
         return merge(left, right)
     
     def merge(left, right):
         result = []
         i = j = 0
         while i < len(left) and j < len(right):
             if left[i] <= right[j]:
                 result.append(left[i])
                 i += 1
             else:
                 result.append(right[j])
                 j += 1
         result.extend(left[i:])
         result.extend(right[j:])
         return result
     ```
     - Language: Ruby on Rails
     ```
     def merge_sort(arr)
         n = arr.length
         if n <= 1
             return arr
         end
         mid = n / 2
         left = merge_sort(arr[0..mid - 1])
         right = merge_sort(arr[mid..n - 1])
         return merge(left, right)
     end
     
     def merge(left, right)
         result = []
         while left.length > 0 && right.length > 0
             if left[0] <= right[0]
                 result.push(left.shift)
             else
                 result.push(right.shift)
             end
         end
         result.concat(left).concat(right)
     end
     ```

2. Searching Algorithms:
   - Binary Search:
     - Explanation: Binary Search is an efficient searching algorithm for finding an element in a sorted array by repeatedly dividing the search interval in half.
     - Language: Perl 5
     ```
     sub binary_search {
         my ($arr, $target) = @_;
         my $low = 0;
         my $high = scalar(@$arr) - 1;
         while ($low <= $high) {
             my $mid = int(($low + $high) / 2);
             if ($arr->[$mid] == $target) {
                 return $mid;
             } elsif ($arr->[$mid] < $target) {
                 $low = $mid + 1;
             } else {
                 $high = $mid - 1;
             }
         }
         return -1;
     }
     ```
     - Language: Python
     ```
     def binary_search(arr, target):
         low = 0
         high = len(arr) - 1
         while low <= high:
             mid = (low + high) // 2
             if arr[mid] == target:
                 return mid
             elif arr[mid] < target:
                 low = mid + 1
             else:
                 high = mid - 1
         return -1
     ```
     - Language: Ruby on Rails
     ```ruby
     def binary_search(arr, target)
         low = 0
         high = arr.length - 1
         while low <= high
             mid = (low + high) / 2
             if arr[mid] == target
                 return mid
             elsif arr[mid] < target
                 low = mid + 1
             else
                 high = mid - 1
             end
         end
         return -1
     end
     ```

   - Binary Search Tree:
     - Explanation: Binary Search Trees are hierarchical data structures that store elements in a sorted order and allow efficient insertion, deletion, and search operations.
     - Language: Perl 5
     ```
     package Node;
     
     sub new {
         my $class = shift;
         my $value = shift;
         my $self = {
             value => $value,
             left => undef,
             right => undef
         };
         bless $self, $class;
         return $self;
     }
     
     package BST;
     
     sub new {
         my $class = shift;
         my $self = {
             root => undef
         };
         bless $self, $class;
         return $self;
     }
     
     sub insert {
         my ($self, $value) = @_;
         $self->{root} = _insert_node($self->{root}, $value);
     }
     
     sub _insert_node {
         my ($node, $value) = @_;
         unless ($node) {
             return Node->new($value);
         }
         if ($value < $node->{value}) {
             $node->{left} = _insert_node($node->{left}, $value);
         } else {
             $node->{right} = _insert_node($node->{right}, $value);
         }
         return $node;
     }
     
     sub search {
         my ($self, $value) = @_;
         return _search_node($self->{root}, $value);
     }
     
     sub _search_node {
         my ($node, $value) = @_;
         return undef unless $node;
         if ($value == $node->{value}) {
             return $node;
         } elsif ($value < $node->{value}) {
             return _search_node($node->{left}, $value);
         } else {
             return _search_node($node->{right}, $value);
         }
     }
     ```
     - Language: Python
     ```
     class Node:
         def __init__(self, value):
             self.value = value
             self.left = None
             self.right = None
     
     class BinarySearchTree:
         def __init__(self):
             self.root = None
     
         def insert(self, value):
             self.root = self._insert_node(self.root, value)
     
         def _insert_node(self, node, value):
             if node is None:
                 return Node(value)
             if value < node.value:
                 node.left = self._insert_node(node.left, value)
             else:
                 node.right = self._insert_node(node.right, value)
             return node
     
         def search(self, value):
             return self._search_node(self.root, value)
     
         def _search_node(self, node, value):
             if node is None or node.value == value:
                 return node
             if value < node.value:
                 return self._search_node(node.left, value)
             else:
                 return self._search_node(node.right, value)
     ```
     - Language: Ruby on Rails
     ```
     class Node
         attr_accessor :value, :left, :right
     
         def initialize(value)
             @value = value
             @left = nil
             @right = nil
         end
     end
     
     class BinarySearchTree
         attr_accessor :root
     
         def initialize
             @root = nil
         end
     
         def insert(value)
             @root = _insert_node(@root, value)
         end
     
         def _insert_node(node, value)
             if node.nil?
                 return Node.new(value)
             end
             if value < node.value
                 node.left = _insert_node(node.left, value)
             else
                 node.right = _insert_node(node.right, value)
             end
             return node
         end
     
         def search(value)
             return _search_node(@root, value)
         end
     
         def _search_node(node, value)
             return nil if node.nil? || node.value == value
             if value < node.value
                 return _search_node(node.left, value)
             else
                 return _search_node(node.right, value)
             end
         end
     end
     ```

Note: The provided code examples cover the basic implementation of each algorithm and may require modifications or adaptations based on specific requirements or language-specific conventions.
k
